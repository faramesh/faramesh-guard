#!/usr/bin/env python3
"""
TUF Metadata Signing Tool

Signs TUF metadata files (root.json, targets.json, snapshot.json, timestamp.json)
using Ed25519 keys generated by tuf-keygen.sh.

Usage:
    python scripts/tuf-sign.py --role root
    python scripts/tuf-sign.py --role targets
    python scripts/tuf-sign.py --role snapshot
    python scripts/tuf-sign.py --role timestamp
    python scripts/tuf-sign.py --all  # Sign all roles
"""

import argparse
import base64
import hashlib
import json
import os
import sys
from datetime import datetime, timedelta
from pathlib import Path

try:
    from cryptography.hazmat.primitives import serialization
    from cryptography.hazmat.primitives.asymmetric.ed25519 import Ed25519PrivateKey
except ImportError:
    print("âŒ Missing dependency: cryptography")
    print("   Install with: pip install cryptography")
    sys.exit(1)

# Default paths
TUF_DIR = Path(os.environ.get("TUF_DIR", Path.home() / ".guard-tuf"))
KEYS_DIR = TUF_DIR / "keys"
REPO_DIR = TUF_DIR / "repository"
METADATA_DIR = REPO_DIR / "metadata"

# Expiry periods
EXPIRY_DAYS = {
    "root": 365,
    "targets": 90,
    "snapshot": 30,
    "timestamp": 1,
}


def load_private_key(role: str) -> Ed25519PrivateKey:
    """Load the private key for a role."""
    key_path = KEYS_DIR / role / "private.pem"
    if not key_path.exists():
        raise FileNotFoundError(f"Private key not found: {key_path}")

    with open(key_path, "rb") as f:
        key_data = f.read()

    return serialization.load_pem_private_key(key_data, password=None)


def load_key_id(role: str) -> str:
    """Load the key ID for a role."""
    key_id_path = KEYS_DIR / role / "key_id.txt"
    if not key_id_path.exists():
        raise FileNotFoundError(f"Key ID not found: {key_id_path}")

    return key_id_path.read_text().strip()


def load_metadata(role: str) -> dict:
    """Load metadata file for a role."""
    metadata_path = METADATA_DIR / f"{role}.json"
    if not metadata_path.exists():
        raise FileNotFoundError(f"Metadata not found: {metadata_path}")

    with open(metadata_path) as f:
        return json.load(f)


def save_metadata(role: str, metadata: dict):
    """Save metadata file for a role."""
    metadata_path = METADATA_DIR / f"{role}.json"
    with open(metadata_path, "w") as f:
        json.dump(metadata, f, indent=2, sort_keys=True)
    print(f"   âœ“ Saved: {metadata_path}")


def canonical_json(obj: dict) -> bytes:
    """Create canonical JSON representation for signing."""
    return json.dumps(obj, sort_keys=True, separators=(",", ":")).encode("utf-8")


def sign_metadata(signed_data: dict, private_key: Ed25519PrivateKey, key_id: str) -> dict:
    """Sign the 'signed' portion of metadata."""
    # Create canonical JSON of the signed portion
    canonical = canonical_json(signed_data)

    # Sign it
    signature = private_key.sign(canonical)

    # Return signature object
    return {
        "keyid": key_id,
        "sig": base64.b64encode(signature).decode("ascii"),
    }


def update_expiry(signed_data: dict, role: str):
    """Update the expiry timestamp."""
    days = EXPIRY_DAYS.get(role, 30)
    expiry = datetime.utcnow() + timedelta(days=days)
    signed_data["expires"] = expiry.strftime("%Y-%m-%dT%H:%M:%SZ")


def compute_file_hash(file_path: Path) -> dict:
    """Compute SHA-256 hash and length of a file."""
    content = file_path.read_bytes()
    sha256_hash = hashlib.sha256(content).hexdigest()
    return {
        "length": len(content),
        "hashes": {
            "sha256": sha256_hash,
        },
    }


def sign_role(role: str, increment_version: bool = True):
    """Sign a single role's metadata."""
    print(f"\nğŸ” Signing {role}.json...")

    # Load key and metadata
    private_key = load_private_key(role)
    key_id = load_key_id(role)
    metadata = load_metadata(role)

    # Get the signed portion
    signed_data = metadata.get("signed", metadata)

    # Increment version if requested
    if increment_version:
        signed_data["version"] = signed_data.get("version", 0) + 1
        print(f"   âœ“ Version: {signed_data['version']}")

    # Update expiry
    update_expiry(signed_data, role)
    print(f"   âœ“ Expires: {signed_data['expires']}")

    # If this is snapshot, update meta references
    if role == "snapshot":
        targets_path = METADATA_DIR / "targets.json"
        if targets_path.exists():
            targets_meta = load_metadata("targets")
            signed_data["meta"] = {
                "targets.json": {
                    "version": targets_meta["signed"]["version"],
                }
            }
            print(f"   âœ“ Updated targets.json reference (v{targets_meta['signed']['version']})")

    # If this is timestamp, update snapshot reference with hash
    if role == "timestamp":
        snapshot_path = METADATA_DIR / "snapshot.json"
        if snapshot_path.exists():
            snapshot_meta = load_metadata("snapshot")
            file_info = compute_file_hash(snapshot_path)
            signed_data["meta"] = {
                "snapshot.json": {
                    "version": snapshot_meta["signed"]["version"],
                    **file_info,
                }
            }
            print(f"   âœ“ Updated snapshot.json reference (v{snapshot_meta['signed']['version']})")

    # Create signature
    signature = sign_metadata(signed_data, private_key, key_id)

    # Build final metadata structure
    final_metadata = {
        "signed": signed_data,
        "signatures": [signature],
    }

    # Save
    save_metadata(role, final_metadata)
    print(f"   âœ“ Signed with key: {key_id}")


def sign_all():
    """Sign all roles in the correct order."""
    # Order matters: targets -> snapshot -> timestamp
    # Root is special and usually signed separately

    print("\nâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•")
    print("Signing all TUF metadata")
    print("â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•")

    # Sign in dependency order
    for role in ["root", "targets", "snapshot", "timestamp"]:
        sign_role(role)

    print("\nâœ… All metadata signed!")


def verify_signature(role: str):
    """Verify the signature on a role's metadata."""
    from cryptography.hazmat.primitives.asymmetric.ed25519 import Ed25519PublicKey

    print(f"\nğŸ” Verifying {role}.json...")

    # Load public key
    pub_key_path = KEYS_DIR / role / "public.pem"
    with open(pub_key_path, "rb") as f:
        public_key = serialization.load_pem_public_key(f.read())

    # Load metadata
    metadata = load_metadata(role)

    if not metadata.get("signatures"):
        print(f"   âŒ No signatures found!")
        return False

    # Get the signed portion and signature
    signed_data = metadata["signed"]
    signature = metadata["signatures"][0]

    # Verify
    canonical = canonical_json(signed_data)
    sig_bytes = base64.b64decode(signature["sig"])

    try:
        public_key.verify(sig_bytes, canonical)
        print(f"   âœ… Signature valid (key: {signature['keyid']})")
        return True
    except Exception as e:
        print(f"   âŒ Signature invalid: {e}")
        return False


def main():
    parser = argparse.ArgumentParser(
        description="Sign TUF metadata files",
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Examples:
    %(prog)s --role root       Sign root.json
    %(prog)s --role targets    Sign targets.json
    %(prog)s --all             Sign all roles in order
    %(prog)s --verify root     Verify root.json signature
        """,
    )

    parser.add_argument(
        "--role",
        choices=["root", "targets", "snapshot", "timestamp"],
        help="Role to sign",
    )
    parser.add_argument(
        "--all",
        action="store_true",
        help="Sign all roles in dependency order",
    )
    parser.add_argument(
        "--verify",
        choices=["root", "targets", "snapshot", "timestamp"],
        help="Verify signature on a role",
    )
    parser.add_argument(
        "--no-increment",
        action="store_true",
        help="Don't increment version number",
    )

    args = parser.parse_args()

    # Validate paths exist
    if not KEYS_DIR.exists():
        print(f"âŒ Keys directory not found: {KEYS_DIR}")
        print("   Run ./scripts/tuf-keygen.sh first")
        sys.exit(1)

    if not METADATA_DIR.exists():
        print(f"âŒ Metadata directory not found: {METADATA_DIR}")
        print("   Run ./scripts/tuf-bootstrap.sh first")
        sys.exit(1)

    print("â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—")
    print("â•‘       Faramesh Guard - TUF Metadata Signing                  â•‘")
    print("â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•")
    print(f"\nğŸ“ Repository: {REPO_DIR}")

    if args.verify:
        verify_signature(args.verify)
    elif args.all:
        sign_all()
    elif args.role:
        sign_role(args.role, not args.no_increment)
        print(f"\nâœ… {args.role}.json signed!")
    else:
        parser.print_help()
        sys.exit(1)

    # Show next steps
    print("\nâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•")
    print("Next Steps")
    print("â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•")
    print("\nUpload signed metadata to R2:")
    print(f"  wrangler r2 object put guard-tuf/metadata/root.json --file {METADATA_DIR}/root.json --remote")
    print(f"  wrangler r2 object put guard-tuf/metadata/targets.json --file {METADATA_DIR}/targets.json --remote")
    print(f"  wrangler r2 object put guard-tuf/metadata/snapshot.json --file {METADATA_DIR}/snapshot.json --remote")
    print(f"  wrangler r2 object put guard-tuf/metadata/timestamp.json --file {METADATA_DIR}/timestamp.json --remote")


if __name__ == "__main__":
    main()
